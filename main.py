from Solution import Solution, Node, LRUCache

if __name__ == '__main__':
    solution = Solution()
    # print(solution.subsetsWithDup([4, 4, 4, 1, 4]))
    # print(solution.numDecodings("226"))
    # solution.printListNode(solution.reverseBetween(solution.createLinkList([1,5]), 1, 2))
    # print(solution.restoreIpAddresses("010010"))
    # solution.printBinaryTree(solution.buildTree([9,3,15,20,7], [9,15,7,20,3]))
    # print(solution.isBalanced(solution.createBinaryTree([3, 9, 20, None, None, 15, 7])))
    # solution.printListNode(solution.flatten(solution.createBinaryTree([1,2,5,3,4,None,6])))
    # print(solution.generate(5))
    # print(solution.getRow(3))
    # print(solution.minimumTotal([
    #     [2],
    #     [3, 4],
    #     [6, 5, 7],
    #     [4, 1, 8, 3]
    # ]))
    # print(solution.maxProfit_ii([1, 2, 3, 4, 5]))
    # print(solution.lengthOfLIS([1,3,6,7,9,4,10,5,6]))
    # print(solution.isPalindromeStr("0P"))
    # print(solution.ladderLength("a", "c", ["a","b","c"]))
    # print(solution.ladderLength("hot", "dog", ["hot", "dog", "dot"]))
    # print(solution.ladderLength("hit", "cog", ["hot", "dot", "dog", "lot", "log", "cog"]))
    # print(solution.ladderLength("red", "tax", ["ted", "tex", "red", "tax", "tad", "den", "rex", "pee"]))
    # print(solution.spiralOrder([
    #     [1, 2, 3],
    #     [4, 5, 6],
    #     [7, 8, 9]
    # ]))
    # print(solution.sumNumbers(solution.createBinaryTree([1, 2, 3])))
    # print(solution.coinChange([2], 3))
    # board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
    # solution.solve_surrounded_regions(board)
    # print(board)
    # print(solution.palindrome_partition("efefeswrerws"))
    # one = Node(1)
    # two = Node(2)
    # three = Node(3)
    # four = Node(4)
    # one.neighbors = [two, four]
    # two.neighbors = [one, three]
    # three.neighbors = [two, four]
    # four.neighbors = [one, three]
    # solution.cloneGraph(one)
    # print(solution.canCompleteCircuit([1, 2, 3, 4, 5], [3, 4, 5, 1, 2]))
    # print(solution.canThreePartsEqualSum([0, 2, 1, -6, 6, -7, 9, 1, 2, 0, 1]))
    # print(solution.canThreePartsEqualSum([0, 2, 1, -6, 6, 7, 9, -1, 2, 0, 1]))
    # print(solution.canThreePartsEqualSum([3, 3, 6, 5, -2, 2, 5, 1, -9, 4]))
    # print(solution.canThreePartsEqualSum([1, -1, 1, -1]))
    # print(solution.wordBreak("a", ['b']))
    # link = solution.createLinkList([1, 2, 3, 4])
    # solution.reorderList(link)
    # solution.printListNode(link)
    # cache = LRUCache(2)
    # cache.put(1, 1)
    # cache.put(2, 2)
    # print(cache.get(1))
    # cache.put(3, 3)
    # print(cache.get(2))
    # cache.put(4, 4)
    # print(cache.get(1))
    # print(cache.get(3))
    # print(cache.get(4))
    # solution.printListNode(solution.insertionSortList(solution.createLinkList([4,19,14,5,-3,1,8,5,11,15])))
    # solution.printListNode(solution.sortList(solution.createLinkList([4, 19, 14, 5, -3, 1, 8, 5, 11, 15])))
    # print(solution.maxAreaOfIsland([[0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
    #                                 [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
    #                                 [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
    #                                 [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],
    #                                 [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0],
    #                                 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
    #                                 [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
    #                                 [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]]))
    # print(solution.maxPathSum(solution.createBinaryTree([5, 4, 8, 11, None, 13, 4, 7, 2, None, None, None, 1])))
    # print(solution.candy([1, 2, 3, 4, 2, 1, 2, 2, 3, 0, 1, 3, 4, 5, 100]))
    print(solution.compressString("aabcccccaa"))
